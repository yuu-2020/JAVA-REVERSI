//                                                 ..NMM~MMMMMMMMMMMMNNnN
//                                           ....(+gggmmmmggggMMMMMM8Od#
//                                    ..JgMMMBUVZwrrrrwQggM#6OMNgMNMBGMN,.
//                                .JHMBUwrrv<:::::<zrdM5<dNZvMMNZdNZqMBXHMMNJ,
//                            .(MM8wrrrrrrZ;:::::::+rWNJ-(MNesyWNgNMM0rrrrrvVMMNJ.
//                         .JMMSrrrrrrrrrrro+;;;;++OrrZVHMMBWHHH9UwrrrrrrrrrrrrZTMNJ.              
//                       .MMSrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrZHMN,     
//                    ..MBVrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrVMN,
//                   .MBwrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrXMN,       
//                 .dM0rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrwWMm.
//                .MBrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrXMN,
//               (MSrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrZWMp
//              (MSrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrZWMp   
//             .MSrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrtrrrtrrrtrrrrrrrrrrrrrZWM[
//            .MHwrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrtrrrrrrrrtrrrtrrrtrrrrrrrrrrrrrrrrrrrrrrrrrXWN,
//            d#SrrrrrrrrrrrrrrrrrrrrrrtrrrtrwAQgNHMMMMMMMMMMNNggywrrrrrrrrrrrrrrrrtrrrrrrrrrrwVMb
//           .MH0rrrrrrrrrrrrrrtrrrtrrrrrAgNMMHWVyVVVVVVy)      ?TWMNmyrrrrrrrrrrrrrrrrrrrrrrrrXWM-
//           .MWVrrrrrrrrrrtrrrrrrrrrrQgMMHVVVyVyVyVVVVyV)           ?TMNyrrrrrrrrrrrrrrrrrrrrrdWM]
//           (NVkrrrrrrrrrrrrrrrrrrwgMMWyyVyVyVyVyyyyyyVy:              (TNmOrrtrrrrrrrtrrrrrrrdVMF
//          (NfkrrrrrrrrrrrrrrrrrqMMVyVyVyVyVyVyVVVyVVyf                  TNmrrrrrrrrrrrrrrrrrdyMF
//          ,MWywrrrrrrrrrrrrrrwdMWyVVyVyVyVyVyVyyVVyVf`                   .WNyrrrrtrrrrrrrrrwXVMF
//            MNVWwrrrrrtrrrrrrwMMVyVyyVyVyVyVyVyVyyVyY                       7NyrrrrrrrrrrrrwXVWM\
//            dNVVVkwrrrrrrrrrrdMVVyVVyVyVyVyVyVyVVV=`                         dNrrrrrrrrrrrwXVyM#
//            .MNyVyykwrrrrrrrdMWWyVyyVyVyVyVWUV7^`                            .MKrrrrrrrrwXyVVWM\
//             ,MHVVVVyWwwrrrrd#      ````                                      d#rrrrrwwyVyVyWMF
//              ?MkyVVVVyVykwwd#                                                d#rwwXyyVVyVVVM@
//               /MHVyyVVyVVyVWN<        .JMNN,                  .JMNN.          MNyVyVVVVyVVWM@`
//                ,MNVVyVVyVVyVMb        MNMMMN.                MNMMMN.        (MVVVyVyVyVVWMF
//                  TNkVVyVyVVVWMb       ?MMMMF                 vMMMM#        .MHVVyVVyVVWNM^
//                   .WNkVVyVyVVWMN,       _~        ,MMM`       .""^       .(MHVVyVVyVVWMD
//                     (WNkVVyVVVVWMm. .jzrzr&-_ a,...JMm....N  (+j+z&-.   .MMfVVyVVyWqMD`         
//                       .TNNkyVyVVVHMN,_?+<<<!   7T""! -7""!   ~?Ovz<7!.(MMWVVVyVVWNM"`
//                          ?WNmkVyVVVWMMm,.                         .(MMMVVVyVVWNM@^
//                             ?WMNkWyVVVWMMMNJ...             ...gMMMHyVVyVWQNM9^
//                                .7WMNNkWVVVVWHMMMMHMNNNNMMMMMMMHVVVyVWQNMM9=`
//                                 .MB""TMMMNNmQQkkffVVfVfVVfWWWQQNNMMMMMMa,                      
//                               .MY     .Mp  _?7""""WHHHHH"""""=!` .M=   -TN,
//                              .M'       .M[                      .#!      (M,               
//                              M%         ,N,.MMMMMMMMMMMMMY"Hm. .#`        ,N.
//                             .M`          db.Ngggggggggggga.JM}.M'          M[                   
//                             .M_          .MJN0wZZZZZZZZZZwd#MlMt           M%            
//                              dN,          dMMNm-:::::::::ddMMM@           .#!
//                               MMa.            7MmttttttOd#=             .JM^       
//                              .MHHMm,           (MrrrrrrdM`            .gMM#                    
//                              .MyyVWTNa,        (#rrrrrrdM,         .&MMHVWN
//                        .gMNg,j#yVy%  (Wm.     .MSrrrrrrrdN,     .k#"`,VyyWM&MMMN,          
//                      .d@`  _TMNVW=     ?Mg...MBwrrrrrrrrrVMa...dB'   .VVWM#^   .Wm.
//                     .M%       TN[         ?7NVrrrrrrrrrrrrd#MY^       (M#'       7N. 
//                     d]         .WN,        .NwrrrrrrrrrrrrdNM:      .(#^          M]
//              ..(+ztdb           (Me       .NXwwwwwwwwwwwwdNM!     .MY           .M6z+-..
//          .(+ttlttltlZMp           .Hb       """"""""""""""""`     .M^           .MElltllltzi-.
//      .JztlltllllllltlZMp            M[                           .M%           .MEtllltllllltttz-.
//   .(llltlltlltltltllllOMN,          (N        ....-(....         (#          .JMSlltlltltllllllltlO-
//  .lllllltlltlltlltltltltdMm,        .NJ(J+gMMMMB9UOOZVWMMMMNmggggMN        .JM8tlllltllllttlltllllllz.
//  zllttlltlltlllltllltlllllZMNa,.   .M@OOOtlllllllllllllllllllltllwMN,....JMM9lllltlltlltllltlltltllll>
//

import java.net.*;
import java.io.*;
import javax.swing.*;
import java.lang.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;
import javax.swing.Timer;//Timerの利用時に必要
import java.io.File;//音楽再生時に必要
import java.applet.*;	//wavファイルの再生に使用
import javax.sound.sampled.AudioFormat;//音楽再生時に必要
import javax.sound.sampled.AudioSystem;//音楽再生時に必要
import javax.sound.sampled.Clip;//音楽再生時に必要
import javax.sound.sampled.DataLine;//音楽再生時に必要

public class MyClient extends JFrame implements MouseListener,MouseMotionListener{
	
	/* グローバル変数 */
	private JButton[][] buttonArray;//ボタン用の配列
	private JButton buttonClear, buttonMute, buttonVolume, buttonTitle;
	private int boardLength = 8;//ボードの一辺の長さ
	private int buttonSize = 60;//ボタンのサイズ
	private int myColor, yourColor;//黒(0),白(1)を格納
	private int myTurn = 0;//ターンを管理する変数
	private int fin = 60; //boardIconの数を格納
	private int end = 0;//1でゲーム終了
	private int myPiece = 0, yourPiece = 0;//盤上の駒の数の設定
	private JLabel myMag, yourMag;//盤上の駒の数を表示するラベル
	private ImageIcon myIcon, yourIcon, clearIcon;//アイコンの管理
	private Container contentPane;//ペイン
	private ImageIcon blackIcon, whiteIcon, boardIcon, markIcon;//オセロのアイコン
	private ImageIcon volumeIcon, muteIcon, titlelogo, mycountIcon, yourcountIcon;//GUIに関するアイコン
	PrintWriter out;//出力用のライター
	private AudioClip BGM = Applet.newAudioClip(getClass().getResource("SOUND/BGM.wav"));
	private AudioClip button = Applet.newAudioClip(getClass().getResource("SOUND/button.wav"));

	//
	//
	//
	//以下，MyClient
	//
	//
	//
	
	public MyClient() {
		
		//
		//
		//
		//以下，GUIに関するプログラム
		//
		//
		//
		
		//名前の入力ダイアログを開く
		String myName = JOptionPane.showInputDialog(null,"名前を入力してください","名前の入力",JOptionPane.QUESTION_MESSAGE);
		if(myName.equals("")) myName = "No name";//名前がないときは，"No name"とする
		
		//IPアドレスの入力ダイアログを開く
		String IpAddress = JOptionPane.showInputDialog(null,"IPアドレスを入力してください","IPアドレスの入力",JOptionPane.QUESTION_MESSAGE);
		if(IpAddress.equals("")) IpAddress = "localhost";//名前がないときは，"localhost"とする
		
		//ウィンドウを作成する
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//ウィンドウを閉じるときに，正しく閉じるように設定する
		setTitle("マグさんのオセロ");//ウィンドウのタイトルを設定する
		setSize(900, 800);//ウィンドウのサイズを設定する
		contentPane = getContentPane();//フレームのペインを取得する
		contentPane.setLayout(null);//自動レイアウトの設定を行わない
		contentPane.setBackground(Color.WHITE);//ウィンドウの色を設定

		//アイコンの設定
		whiteIcon = new ImageIcon("IMG/mag_white60.jpg");
		blackIcon = new ImageIcon("IMG/mag_black60.jpg");
		boardIcon = new ImageIcon("IMG/board.jpg");
		markIcon = new ImageIcon("IMG/mark60.jpg");
		clearIcon = new ImageIcon("IMG/resetbutton.jpg");
		volumeIcon = new ImageIcon("IMG/volume.jpg");
		muteIcon = new ImageIcon("IMG/mute.jpg");
		
		//ボタンの生成
		buttonArray = new JButton[boardLength][boardLength];//ボタンの配列を64個作成する[0][0]から[7][7]まで使える
		for(int i = 0; i < boardLength * boardLength; i++){
			int y = i / 8;
			int x = i % 8;
			
			buttonArray[y][x] = new JButton(boardIcon);//ボタンにアイコンを設定する
			contentPane.add(buttonArray[y][x]);//ペインに貼り付ける
			buttonArray[y][x].setBounds(40 + x * buttonSize, 140 + y * buttonSize, buttonSize, buttonSize);//ボタンの大きさと位置を設定する．(x座標，y座標,xの幅,yの幅）
			buttonArray[y][x].addMouseListener(this);//ボタンをマウスでさわったときに反応するようにする
			buttonArray[y][x].addMouseMotionListener(this);//ボタンをマウスで動かそうとしたときに反応するようにする
			buttonArray[y][x].setActionCommand(Integer.toString(i));//ボタンに配列の情報を付加する（ネットワークを介してオブジェクトを識別するため）
		}

		//リセットボタンの作成
		buttonClear = new JButton(clearIcon);
		buttonClear.setBounds(160, 630, 60, 60);
		buttonClear.addMouseListener(this);
		contentPane.add(buttonClear);
		
		//オセロの初期配置
		buttonArray[3][4].setIcon(blackIcon);
		buttonArray[3][3].setIcon(whiteIcon);
		buttonArray[4][3].setIcon(blackIcon);
		buttonArray[4][4].setIcon(whiteIcon);
		
		//盤上の駒の数をカウント
		myPiece = countPiece(myIcon);
		yourPiece = countPiece(yourIcon);
		
		//駒の数の表示
		myMag = new JLabel(String.valueOf(myPiece));
		myMag.setBounds(650, 475, 100, 50);
		myMag.setFont(new Font("Arial", Font.PLAIN, 40));
		myMag.setForeground(Color.BLACK);
		myMag.setHorizontalAlignment(JLabel.CENTER);
		contentPane.add(myMag, (Integer)380);
		
		yourMag = new JLabel(String.valueOf(yourPiece));
		yourMag.setBounds(650, 575, 100, 50);
		yourMag.setFont(new Font("Arial", Font.PLAIN, 40));
		yourMag.setForeground(Color.BLACK);
		yourMag.setHorizontalAlignment(JLabel.CENTER);
		contentPane.add(yourMag, (Integer)380);
		
		//タイトルロゴ
		ImageIcon titlelogo = new ImageIcon("IMG/titlelogo.jpg");//タイトルロゴ
		JLabel titleLabel = new JLabel(titlelogo);
		titleLabel.setBounds(520, 140, 300, 212);
		titleLabel.setIcon(titlelogo);
		contentPane.add(titleLabel);
		
		//BGMの設定
		BGM.loop();//BGMを再生する
		
		//BGMをミュートするボタンの作成
		buttonMute = new JButton(muteIcon);
		buttonMute.setBounds(40, 630, 60, 60);
		buttonMute.addMouseListener(this);
		contentPane.add(buttonMute);
		//BGMを再生するボタンの作成
		buttonVolume = new JButton(volumeIcon);
		buttonVolume.setBounds(100, 630, 60, 60);
		buttonVolume.addMouseListener(this);
		contentPane.add(buttonVolume);
		
		//サーバに接続する
		Socket socket = null;
		
		//"localhost"は，自分内部への接続．localhostを接続先のIP Address（"133.42.155.201"形式）に設定すると他のPCのサーバと通信できる
		//10000はポート番号．IP Addressで接続するPCを決めて，ポート番号でそのPC上動作するプログラムを特定する
		try {
			socket = new Socket(IpAddress, 10000);
		} catch (UnknownHostException e) {
			System.err.println("ホストの IP アドレスが判定できません: " + e);
		} catch (IOException e) {
			 System.err.println("エラーが発生しました: " + e);
		}
		
		MesgRecvThread mrt = new MesgRecvThread(socket, myName);//受信用のスレッドを作成する
		
		////////////////////////
		//スレッドを動かす（Runが動く）
		mrt.start();
		////////////////////////
	}
	
	//
	//
	//
	//以下，メッセージ受信のためのスレッド
	//
	//
	//
	
	public class MesgRecvThread extends Thread {
		Socket socket;
		String myName;
		
		public MesgRecvThread(Socket s, String n){
			socket = s;
			myName = n;
		}
		
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//通信状況を監視し，受信データによって動作する
		public void run() {
			try{
				InputStreamReader sisr = new InputStreamReader(socket.getInputStream());
				BufferedReader br = new BufferedReader(sisr);
				out = new PrintWriter(socket.getOutputStream(), true);
				out.println(myName);//接続の最初に名前を送る
				//接続番号を受け取る
				String myNumberStr = br.readLine();
				int myNumberInt = Integer.parseInt(myNumberStr);//接続番号
				
				///////////////////////////////
				//・接続番号の値が
				//1.　偶数のときは，myColorが０（黒）
				//2.　奇数のときは，myColorが１（白）
				//
				//・myTurnの値が
				//1．　０なら黒のターン(自分のターン)
				//2．　１なら白のターン(相手のターン)
				///////////////////////////////

				if(myNumberInt % 2 == 0){//接続番号が偶数ならば
					myColor = 0;
					myIcon = blackIcon;
					yourIcon = whiteIcon;
					myTurn = 0;
					
					//自分の駒を表示
					mycountIcon = new ImageIcon("IMG/count_mymag.jpg");
					JLabel myLabel = new JLabel(mycountIcon);
					myLabel.setBounds(520, 352, 300, 278);
					myLabel.setIcon(mycountIcon);
					contentPane.add(myLabel);
					
					//ダイアログに表示
					try{
						"hello".charAt(-1);
					}catch(Exception e){
						JOptionPane.showMessageDialog(null,"先攻　黒マグさん");
					}					
				}else{//接続番号が奇数ならば
					myColor = 1;
					myIcon = whiteIcon;
					yourIcon = blackIcon;
					myTurn = 1;
					
					//自分の駒を表示
					yourcountIcon = new ImageIcon("IMG/count_yourmag.jpg");
					JLabel yourLabel = new JLabel(yourcountIcon);
					yourLabel.setBounds(520, 352, 300, 278);
					yourLabel.setIcon(yourcountIcon);
					contentPane.add(yourLabel);
					
					//ダイアログに表示
					try{
						"hello".charAt(-1);
					}catch(Exception e){
						JOptionPane.showMessageDialog(null,"後攻　白マグさん");
					}
				}
				
				while(true) {
					String inputLine = br.readLine();//データを一行分だけ読み込んでみる
					
					if (inputLine != null) {//読み込んだときにデータが読み込まれたかどうかをチェックする
						String[] inputTokens = inputLine.split(" ");	//入力データを解析するために、スペースで切り分ける
						String cmd = inputTokens[0];//コマンドの取り出し．１つ目の要素を取り出す
						
						///////////////////////////////////////////////////////////////////////////////////
						//ボタンをクリックしたときの位置情報の受信
						if(cmd.equals("PLACE")){
							//コマがおける場所が減る
							//fin--;
							//if(fin == 0) judge();//おける場所が0でゲーム終了
							
							//ボタンの配列名（配列番号）の取得
							String theButtonName = inputTokens[1];
							int theButtonNum = Integer.parseInt(theButtonName);//int型にキャスト
							
							//myColorの値の取得
							int Color = Integer.parseInt(inputTokens[2]);
							
							//座標の設定
							int y = theButtonNum / boardLength;//y座標
							int x = theButtonNum % boardLength;//x座標
														
							//リバーシの色を設定
							if(Color == myColor){
								buttonArray[y][x].setIcon(myIcon);
								button.play();
							} else{
								buttonArray[y][x].setIcon(yourIcon);
								button.play();
							} 
							
							//ターンを終了して，相手のターンにする
							myTurn = 1 - myTurn;
							
							//盤上の駒の数をカウント
							myPiece = countPiece(myIcon);
							yourPiece = countPiece(yourIcon);
							
							//表示の更新
							myMag.setText(String.valueOf(myPiece));
							yourMag.setText(String.valueOf(yourPiece));

							//自分のコマが置ける場所の表示
							if(myTurn == 0) PostingPlace(myIcon);							
							if(myTurn == 1) clearPostingPlace();
							
							//以下，自動パス判定，勝敗判定
							if(Color == myColor){//自分のコマのとき
								int yourCount = 0, myCount = 0;//リバーシが起こる回数
								
								myCount = countReversi(myIcon);
								yourCount = countReversi(yourIcon);
								
								if(yourCount == 0){//相手のおけるコマが0の時
									if(myCount == 0){//自分のおけるコマが0の時
										JOptionPane.showMessageDialog(null, "両者ともおける場所がありません");
										judge();
									}else{//自分はコマがおける場合
										JOptionPane.showMessageDialog(null, "相手のパスです");

										//ターンを終了して，相手のターンにする
										myTurn = 1 - myTurn;
										
										//自分のコマが置ける場所の表示
										if(myTurn == 0) PostingPlace(myIcon);							
										if(myTurn == 1) clearPostingPlace();										
									}
								}
							}else{//自分のコマのとき
								int yourCount = 0, myCount = 0;//リバーシが起こる回数
								
								myCount = countReversi(myIcon);
								yourCount = countReversi(yourIcon);
								
								if(myCount == 0){//自分のおけるコマが0の時
									if(yourCount == 0){//相手のおけるコマが0の時
										JOptionPane.showMessageDialog(null, "両者ともおける場所がありません");
										
										judge();
									}else{//相手はコマがおける場合
										//ダイアログの表示
										JOptionPane.showMessageDialog(null, "パスです");
										
										//ターンを終了して，相手のターンにする
										myTurn = 1 - myTurn;
										
										//自分のコマが置ける場所の表示
										if(myTurn == 0) PostingPlace(myIcon);							
										if(myTurn == 1) clearPostingPlace();										
									}
								}
							}							
						}
						///////////////////////////////////////////////////////////////////////////////////
						
						///////////////////////////////////////////////////////////////////////////////////
						//リバーシが1つ以上発生する場合の位置情報の受信
						if(cmd.equals("FLIP")){
							//ボタンの配列名（配列番号）の取得
							String theButtonName2 = inputTokens[1];
							int theButtonNum2 = Integer.parseInt(theButtonName2);//int型にキャスト
							
							//myColorの取得
							int Color = Integer.parseInt(inputTokens[2]);
							
							//座標の設定
							int y = theButtonNum2 / boardLength;//y座標
							int x = theButtonNum2 % boardLength;//x座標
							
							//リバーシの色を設定
							if(Color == myColor) buttonArray[y][x].setIcon(myIcon);
							else buttonArray[y][x].setIcon(yourIcon);
						}
						///////////////////////////////////////////////////////////////////////////////////
						
						///////////////////////////////////////////////////////////////////////////////////
						if(cmd.equals("CLEAR")){
							//ヒューマンエラー対策
							try{
								"hello".charAt(-1);
							}catch(Exception e){
								String message[] = {"本当にゲームをリセットしますか？"};
								int value = JOptionPane.showConfirmDialog(null, message, "alart", JOptionPane.YES_NO_OPTION);
								if (value == JOptionPane.YES_OPTION){
									end = 0;//ゲーム開始
								
									//myColorの取得
									int Color = Integer.parseInt(inputTokens[1]);
								
									//コマの配置の初期化
									for(int j = 0; j < boardLength; j++){
										for(int i = 0; i < boardLength; i++){
											if((i == 3 && j == 3) || (i == 4 && j == 4)) buttonArray[i][j].setIcon(whiteIcon);
											else if((i == 4 && j == 3) || (i == 3 && j == 4)) buttonArray[i][j].setIcon(blackIcon);
											else buttonArray[i][j].setIcon(boardIcon);
										}
									}
								
									//盤上の駒の数の設定
									myPiece = 0;
									yourPiece = 0;
									
									//盤上の駒の数をカウント
									myPiece = countPiece(myIcon);
									yourPiece = countPiece(yourIcon);
									
									//表示の更新
									myMag.setText(String.valueOf(myPiece));
									yourMag.setText(String.valueOf(yourPiece));
									
								}else JOptionPane.showMessageDialog(null, "ゲームを続けます");
							}
						}
						///////////////////////////////////////////////////////////////////////////////////
						
						///////////////////////////////////////////////////////////////////////////////////
						if(cmd.equals("REPLAY")){
							end = 0;//ゲーム開始
								
							//myColorの取得
							int Color = Integer.parseInt(inputTokens[1]);
						
							//コマの配置の初期化
							for(int j = 0; j < boardLength; j++){
								for(int i = 0; i < boardLength; i++){
									if((i == 3 && j == 3) || (i == 4 && j == 4)) buttonArray[i][j].setIcon(whiteIcon);
									else if((i == 4 && j == 3) || (i == 3 && j == 4)) buttonArray[i][j].setIcon(blackIcon);
									else buttonArray[i][j].setIcon(boardIcon);
								}
							}
						
							//盤上の駒の数の設定
							myPiece = 0;
							yourPiece = 0;
							
							//盤上の駒の数をカウント
							myPiece = countPiece(myIcon);
							yourPiece = countPiece(yourIcon);
							
							//表示の更新
							myMag.setText(String.valueOf(myPiece));
							yourMag.setText(String.valueOf(yourPiece));
							
						}
						///////////////////////////////////////////////////////////////////////////////////
						
						///////////////////////////////////////////////////////////////////////////////////
						if(cmd.equals("MUTE")) BGM.stop();//BGMを止める
						if(cmd.equals("VOLUME")) BGM.loop();//BGMを再生する
						///////////////////////////////////////////////////////////////////////////////////
					} else break;
				}
				
				///////////////////
				//スレッドを止める
				socket.close();
				//////////////////
				
			} catch (IOException e) {
				System.err.println("エラーが発生しました: " + e);
			}
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	
	//main関数
	public static void main(String[] args) {
		MyClient net = new MyClient();
		net.setVisible(true);
	}
  	
	//
	//
	//
	//以下，マウス操作に関するプログラム
	//
	//
	//
	
	public void mouseClicked(MouseEvent e) {//ボタンをクリックしたときの処理
	
		System.out.println("クリック");
		
		JButton theButton = (JButton)e.getComponent();//クリックしたオブジェクトを得る．型が違うのでキャストする
		String theArrayIndex = theButton.getActionCommand();//ボタンの配列の番号を取り出す
		Icon theIcon = theButton.getIcon();//theIconには，現在のボタンに設定されたアイコンが入る
		
		System.out.println("クリックしたアイコン >> " + theIcon);//デバッグ（確認用）に，クリックしたアイコンの名前を出力する

		if(theIcon == boardIcon || theIcon == markIcon){//コマがおいていなければ
			int theArrayNum = Integer.parseInt(theArrayIndex);//ボタンの配列番号（int型にキャスト）
			int y = theArrayNum / boardLength;//y座標
			int x = theArrayNum % boardLength;//x座標
			
			if(myTurn == 0){//自分のターンならば
				if(judgeButton(y, x)){//一つでもひっくり返すコマがあれば
					//送信情報を作成する（受信時には，この送った順番にデータを取り出す．スペースがデータの区切りとなる）
					String msg = "PLACE" + " " + theArrayIndex + " " + myColor;
					
					//サーバに情報を送る
					out.println(msg);//送信データをバッファに書き出す
					out.flush();//送信データをフラッシュ（ネットワーク上にはき出す）する
					repaint();//画面のオブジェクトを描画し直す
				} else JOptionPane.showMessageDialog(null, "そこには配置できません");//置けない
			} else JOptionPane.showMessageDialog(null, "相手のターンです。");
		}
		
		if(theIcon == clearIcon){//盤面をリセットするとき
			//送信情報を作成する（受信時には，この送った順番にデータを取り出す．スペースがデータの区切りとなる）
			String msg = "CLEAR" + " " + myColor;
					
			//サーバに情報を送る
			out.println(msg);//送信データをバッファに書き出す
			out.flush();//送信データをフラッシュ（ネットワーク上にはき出す）する
			repaint();//画面のオブジェクトを描画し直す
		}
		
		if(theIcon == muteIcon){
			//送信情報を作成する（受信時には，この送った順番にデータを取り出す．スペースがデータの区切りとなる）
			String msg = "MUTE";
					
			//サーバに情報を送る
			out.println(msg);//送信データをバッファに書き出す
			out.flush();//送信データをフラッシュ（ネットワーク上にはき出す）する
			repaint();//画面のオブジェクトを描画し直す
		}
		
		if(theIcon == volumeIcon){
			//送信情報を作成する（受信時には，この送った順番にデータを取り出す．スペースがデータの区切りとなる）
			String msg = "VOLUME";
					
			//サーバに情報を送る
			out.println(msg);//送信データをバッファに書き出す
			out.flush();//送信データをフラッシュ（ネットワーク上にはき出す）する
			repaint();//画面のオブジェクトを描画し直す
		}
	}
	
	public void mouseEntered(MouseEvent e) {//マウスがオブジェクトに入ったときの処理
	}
	public void mouseExited(MouseEvent e) {//マウスがオブジェクトから出たときの処理
	}
	public void mousePressed(MouseEvent e) {//マウスでオブジェクトを押したときの処理
	}
	public void mouseReleased(MouseEvent e) {//マウスで押していたオブジェクトを離したときの処理
	}
	public void mouseDragged(MouseEvent e) {//マウスでオブジェクトとをドラッグしているときの処理
	}
	public void mouseMoved(MouseEvent e) {//マウスがオブジェクト上で移動したときの処理
	}
	
	//
	//
	//
	//以下，追加した関数
	//
	//
	//
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//リバーシするための処理
	//
	/***
	*関数名　judgeButton
	*機能　リバーシが発生するかどうかを判断．
	*　　　　コマがおけたらtrue,おけないならfaulse
	*引数　y座標，ｘ座標
	*返り値　判定(T or F)
	***/
	public boolean judgeButton(int y, int x){
		
		///////////////////////////////////////////
		//T or Fを表す変数にflagを使用する．
		//1．隣8方向にあいてのコマがあるか，ひとつずつ見ていく
		//2．ひとつでもあれば，flagをtrueにする．
		///////////////////////////////////////////
		
		boolean flag = false;
				
		for(int j = -1; j <= 1; j++){//自分(j = 0, i = 0)以外の周りの8コマを順に見ていく
			for(int i = -1; i <= 1; i++){
				if (x + i >= 0 && x + i < boardLength && y + j >= 0 && y + j < boardLength) {//フィールド内であれば
						int flipNum = flipButton(y, x, j, i);//リバーシする個数
						
						System.out.println(i + "," + j + "," + flipNum);
						
						if(flipNum >= 1) {	//リバーシが1つ以上発生する場合
							flag = true;
							
							for(int dy = j, dx = i, k = 0; k < flipNum; k++, dx += i, dy += j){
								//ボタンの位置情報を作る
								int msgy = y + dy;
								int msgx = x + dx;
								int theArrayIndex = msgy * boardLength + msgx;
								
								//サーバに情報を送る
								String msg = "FLIP" + " " + theArrayIndex + " " + myColor;	//送信情報
								out.println(msg);	//送信情報をバッファに書き出す
								out.flush();	//送信データをフラッシュ（ネットワーク上にはき出す）する
							}
						}
				}
			}
		}
		
		return flag;
	}
	
	/***
	*関数名　flipButtons
	*機能　一方向にあるコマ群を裏返す命令を送る
	*引数　y座標，ｘ座標，y成分ベクトル，x成分ベクトル
	*返り値　リバーシしたコマの数
	***/
	public int flipButton(int y, int x, int j, int i){
	
		int flipNum = 0;	//裏返ったコマの数を記録
		
		////////////////////////////////////////////////////
		//1.y + dy, x + dxの位置が場外なら，この関数は0を返す（判定終了）
		//2.この位置のアイコンを取得する
		//3.アイコンの種類をみる
		//  a.boardIconなら，この関数は0を返す（判定終了）
		//  b.myIconなら，この関数はflipNumを返す（リバーシ連鎖終了）
		//  c.yourIconなら，flipNumを1増やす（リバーシ連鎖続く）
		////////////////////////////////////////////////////
		
		for(int dy = j, dx = i; ; dy += j, dx += i) {
			int msgy = y + dy;
			int msgx = x + dx;
			
			if (x + dx >= 0 && x +  dx < boardLength && y + dy >= 0 && y + dy < boardLength) {//フィールド内であれば
				Icon theIcon = buttonArray[y + dy][x + dx].getIcon();
				
				System.out.println( (x + dx) + "," + (y + dy));
				
				if(theIcon == boardIcon || theIcon == markIcon) {//a.boardIconなら，この関数は0を返す（判定終了）
					System.out.println("boardIcon");
					return 0;
				}
				if(theIcon == myIcon) {//b.myIconなら，この関数はflipNumを返す（リバーシ連鎖終了）
					System.out.println("myIcon");
					return flipNum;
				}
				if(theIcon == yourIcon) {//c.yourIconなら，flipNumを1増やす（リバーシ連鎖続く）
					System.out.println("yourIcon");
					flipNum++;
				}
			} else return 0;//フィールド外であれば
		}
	}
	//
	//
	//
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	//パス，勝敗判定をする処理
	//
	/***
	*関数名　checkPlace
	*機能　コマを置く場所がないかどうかを自動判定する
	*引数 座標(y, x),ベクトル(j, i),icon
	*返り値 リバーシが発生する個数
	***/
	public int checkPlace(Icon icon, int y, int x, int j, int i){
		int flipNum = 0; //リバーシが発生する個数
		
		////////////////////////////////////////////////////
		//1.y + dy, x + dxの位置が場外なら，この関数は0を返す（判定終了）
		//2.この位置のアイコンを取得する
		//3.アイコンの種類をみる
		//  a.boardIconなら，この関数は0を返す（判定終了）
		//  b.自分自身なら，この関数はflipNumを返す
		//  c.相手のアイコンなら，flipNumを1増やす
		////////////////////////////////////////////////////
		
		for(int dy = j, dx = i; ; dy += j, dx += i){
			if(y + dy >= 0 && y + dy < boardLength && x + dx > 0 && x + dx < boardLength){ //フィールド内であれば
				Icon theIcon = buttonArray[y + dy][x + dx].getIcon(); //アイコンの取得
			
				if(theIcon == boardIcon || theIcon == markIcon) return 0;//a.boardIconなら，この関数は0を返す（判定終了）
				else if(theIcon == icon) return flipNum;//b.自分自身なら，この関数はflipNumを返す
				else flipNum++;//c.相手のアイコンなら，flipNumを1増やす
			}else return 0;//フィールド外であれば
		}
	}
	/***
	*関数名 countPiece
	*機能 ボード上のコマの数を数える
	*引数　数えたいコマのアイコン
	*返り値　コマの数
	***/
	public int countPiece(Icon icon){
		int piece = 0;
		
		for(int j = 0; j < boardLength; j++){
			for(int i = 0; i < boardLength; i++){
				if(buttonArray[j][i].getIcon() == icon) piece++;
			}
		}
		
		return piece;
	}
	/***
	*関数名　judge
	*機能　勝敗を判定する
	*引数　なし
	*返り値　なし
	***/
	public void judge(){
		int myPiece = 0, yourPiece = 0;//盤上の駒の数
		//盤上の駒の数をカウント
		myPiece = countPiece(myIcon);
		yourPiece = countPiece(yourIcon);
		
		if(myPiece > yourPiece) JOptionPane.showMessageDialog(null, "You win!");
		else if(myPiece < yourPiece) JOptionPane.showMessageDialog(null, "You loose...");
		else JOptionPane.showMessageDialog(null, "Draw");
		
		end = 1;//ゲーム終了
		//もう一度プレイするか，ゲームを終了するかをプレイヤーに確認する
		if(end == 1){
			try{
				"hello".charAt(-1);
			}catch(Exception exception){
				String message[] = {"もう一度プレイしますか？"};
				int value = JOptionPane.showConfirmDialog(null, message, "alart", JOptionPane.YES_NO_OPTION);
				if(value == JOptionPane.YES_OPTION){
					String msg = "REPLAY" + " " + myColor;
					
					//サーバに情報を送る
					out.println(msg);//送信データをバッファに書き出す
					out.flush();//送信データをフラッシュ（ネットワーク上にはき出す）する
					repaint();//画面のオブジェクトを描画し直す
				}else System.exit(0);
			}
		}		
	}

	/***
	*関数名　PostingPlace
	*機能　コマがおける場所を表示する
	*引数　自分のアイコン
	*返り値　なし
	***/
	public void PostingPlace(Icon icon){
		for(int y = 0; y < boardLength; y++){
			for(int x = 0; x < boardLength; x++){
				if(buttonArray[y][x].getIcon() == boardIcon){//コマがおいていない場所であれば
					for(int j = -1; j <= 1; j++){//単位ベクトルを与えてパスをカウントする
						for(int i = -1; i <= 1; i++){
							//コマがおける場所を確認
							if(checkPlace(icon, y, x, j, i) > 0){
								buttonArray[y][x].setIcon(markIcon);
							}
						}
					}
				}
			}
		}
	}
	
	/***
	*関数名　clearPostingPlace
	*機能　コマがおける場所の表示をクリアする
	*引数　なし
	*返り値　なし
	***/
	public void clearPostingPlace(){
		for(int y = 0; y < boardLength; y++){
			for(int x = 0; x < boardLength; x++){
				if(buttonArray[y][x].getIcon() == markIcon) buttonArray[y][x].setIcon(boardIcon);
			}
		}
	}
	
	/***
	*関数名　countReversi
	*機能　リバーシが起こる回数をカウントする
	*引数　自分のアイコン
	*返り値　リバーシが起こる回数
	***/
	public int countReversi(Icon icon){
		int Count = 0;

		for(int y = 0; y < boardLength; y++){
			for(int x = 0; x < boardLength; x++){
				if(buttonArray[y][x].getIcon() == boardIcon || buttonArray[y][x].getIcon() == markIcon){//コマがおいていない場所であれば
					for(int j = -1; j <= 1; j++){//単位ベクトルを与えてパスをカウントする
						for(int i = -1; i <= 1; i++){
							//リバーシが起こる回数をカウント
							Count += checkPlace(icon, y, x, j, i);
						}
					}
				}
			}
		}
		
		return Count;
	}
}
//
//
//
///cording by Yudai Asano(SI:60206006)